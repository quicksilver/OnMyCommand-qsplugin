//**************************************************************************************// Filename:	AMacResHandle.h//				Part of Contextual Menu Workshop by Abracode Inc.//				http://free.abracode.com/cmworkshop/// Copyright © 2003 Abracode, Inc.  All rights reserved.//// Description:	Extension to David Catmull's ACCELA Mac toolbox C++ wrapper library//**************************************************************************************#pragma once#include "AMacHandle.h"#include "CThrownResult.h"template <class T>class AMacResHandle :		public AMacHandle<T>{public:		AMacResHandle() {}			AMacResHandle(SInt32 inSize, EMemObjClearOption inClearOption = kMemObj_DontClearMemory)			: AMacHandle<T>(inSize, inClearOption) {}				AMacResHandle(				T** inMacH,				EMemObjOwnershipType inIsOwner = kMemObj_Owned)			: AMacHandle<T>(inMacH, inIsOwner) {}				AMacResHandle(				const T *inPtr,				SInt32 inSize)			: AMacHandle<T>(inPtr, inSize) {}		AMacResHandle(const AMacResHandle& inOrig, EMemObjCopyType inCopyParam = kMemObj_ShallowCopy)			: AMacHandle<T>(inOrig, inCopyParam) {}	virtual		~AMacResHandle() { Dispose(); }		//object assignment as a shallow copy with ownership change	AMacResHandle&		operator=(				const AMacResHandle& inMacHandle)		{			EMemObjOwnershipType isOwner = inMacHandle.mIsOwner;			Reset(inMacHandle.Detach(), isOwner );			return *this;		}		//plain pointer assignment with ownership taking, no copy		//inMacH must be allocated with NewHandle or NewHandleClear or obtained from resources	AMacResHandle&		operator=(				const Handle inMacH)		{			Reset(reinterpret_cast<T**>(const_cast<Handle>(inMacH)), kMemObj_Owned);			return *this;		}	bool		IsResource()		{			::GetResAttrs(reinterpret_cast<Handle>(mObject));			return ::ResError() != resNotFound;		}	void		Dispose()		{			if (mObject != NULL)			{				if(mIsOwner == kMemObj_Owned) DisposeSelf();				mObject = NULL;			}			mIsOwner = kMemObj_NotOwned;		}//DisposeProc receives a pointer to stored object, not the actual object//DisposeProc is responsible for checking if the object stored is valid	static void		DisposeProc(void *inObj)		{			if(inObj != NULL)			{				Handle *objPtr = reinterpret_cast<Handle *>(inObj);				if(*objPtr != NULL)				{					::GetResAttrs(*objPtr);					if(::ResError() != resNotFound)						::ReleaseResource(*objPtr);					else						::DisposeHandle(*objPtr);				}								*objPtr = NULL;			}		}protected:	void		DisposeSelf()		{			if (IsResource())				::ReleaseResource(reinterpret_cast<Handle>(mObject));			else				::DisposeHandle(reinterpret_cast<Handle>(mObject));		}};typedef AMacResHandle<char> AResHandle;