//**************************************************************************************// Filename:	AEAliasList.cp//				Part of Contextual Menu Workshop by Abracode Inc.//				http://free.abracode.com/cmworkshop/// Copyright © 2002-2003 Abracode, Inc.  All rights reserved.//// Description:	Lightweight list of alias objects stored in AEDescList//				Main design features://				- the acutal list can be owned by this object or not//				(there are many cases when we do not want this object to destroy the list)//				- designed not to throw exceptions//				- the list is 1-based//				- no attempt is made to eliminate duplicates (ie pointing to the same objects)////**************************************************************************************// Revision History:// Monday, August 12, 2002 - Original//**************************************************************************************#include "AEAliasList.h"#include "StAEDesc.h"#include "CMUtils.h"AEAliasList::AEAliasList(void){	mList.descriptorType = typeNull;	mList.dataHandle = NULL;	OSErr err = ::AECreateList( NULL, 0, false, &mList );	if(err == noErr)	{		mOwnList = true;	}	//what can I do about the error here?	//I do nothing, hoping that mList.dataHandle will be null if error occured}AEAliasList::AEAliasList(const AEDescList *inList, Boolean inTakeOwnership, Boolean inCopyList /*= false*/){	mList.descriptorType = typeNull;	mList.dataHandle = NULL;	mOwnList = false;		if(inCopyList)	{		CopyList( inList );//if you copy list, you always take ownership of it. inTakeOwnership is ignored	}	else	{		if(inTakeOwnership)		{			AdoptList( inList );//take ownership without copying		}		else if(inList != NULL)		{			mList = *inList;//just assign it		}	}}AEAliasList::~AEAliasList(void){	DisposeOfList();}SInt32AEAliasList::GetCount() const{	if( mList.dataHandle == NULL )		return 0;	SInt32 theCount = 0;	if( ::AECountItems( &mList, &theCount) == noErr )		return theCount;		return 0;}//add item to the end of the listOSErrAEAliasList::AddItem(const FSRef *inRef){	if( inRef == NULL)		return paramErr;	if( mList.dataHandle == NULL )		return nilHandleErr;	StAEDesc objDesc;	OSErr err = CMUtils::CreateAliasDesc( inRef, objDesc );	if(err == noErr)	{		err = ::AEPutDesc( &mList, 0, objDesc );	}	return err;}//add item to the end of the listOSErrAEAliasList::AddItem(const FSSpec *inFSSpec){	if( inFSSpec == NULL)		return paramErr;	if( mList.dataHandle == NULL )		return nilHandleErr;	StAEDesc objDesc;	OSErr err = CMUtils::CreateAliasDesc( inFSSpec, objDesc );	if(err == noErr)	{		err = ::AEPutDesc( &mList, 0, objDesc );	}	return err;}//add item to the end of the listOSErrAEAliasList::AddItem(const AliasHandle inAliasH){	if( inAliasH == NULL)		return paramErr;	if( mList.dataHandle == NULL )		return nilHandleErr;	StAEDesc objDesc;	OSErr err = CMUtils::CreateAliasDesc( inAliasH, objDesc );		if(err == noErr)	{		err = ::AEPutDesc( &mList, 0, objDesc );	}	return err;}//remember: 1-based indexesOSErrAEAliasList::FetchItemAt(SInt32 inIndex, FSSpec &outSpec) const{	if( mList.dataHandle == NULL )		return nilHandleErr;	StAEDesc objDesc;	AEKeyword theKeyword;	OSErr err = ::AEGetNthDesc(&mList, inIndex, typeWildCard, &theKeyword, objDesc);	if (err == noErr)	{		err = CMUtils::GetFSSpec(objDesc, outSpec);	}	return err;}//remember: 1-based indexesOSErrAEAliasList::FetchItemAt(SInt32 inIndex, FSRef &outRef) const{	if( mList.dataHandle == NULL )		return nilHandleErr;	StAEDesc objDesc;	AEKeyword theKeyword;	OSErr err = ::AEGetNthDesc(&mList, inIndex, typeWildCard, &theKeyword, objDesc);	if (err == noErr)	{		err = CMUtils::GetFSRef(objDesc, outRef);	}	return err;}//remember: 1-based indexesOSErrAEAliasList::RemoveItemAt(SInt32 inIndex){	if( mList.dataHandle == NULL )		return nilHandleErr;	return ::AEDeleteItem( &mList, inIndex);}OSErrAEAliasList::RemoveAllItems(){	if( mList.dataHandle == NULL )		return nilHandleErr;	OSErr err = noErr;	SInt32 theCount = GetCount();	for(SInt32 i = 1; i<= theCount; i++)	{		err = ::AEDeleteItem( &mList, i);		if(err != noErr)			break;	}	return err;}OSErrAEAliasList::CopyList(const AEDescList *inList){	if( inList == NULL )		return nilHandleErr;	if( inList->dataHandle == NULL )		return nilHandleErr;	if( mOwnList && (inList->dataHandle == mList.dataHandle) )	{//self assignment case - when we own the list, there is no need to copy it		return noErr;	}	AEDescList newList = {typeNull, NULL};	OSErr err = ::AEDuplicateDesc( inList, &newList);	if( err == noErr )	{		DisposeOfList();//it is now safe to destroy our previous data		mList = newList;		mOwnList = true;	}	return err;}//take ownership of the listOSErrAEAliasList::AdoptList(const AEDescList *inList){	if( inList == NULL )		return nilHandleErr;	//check for self assignment, disposing of our data and then assigning it would be catastrophic	if( inList->dataHandle == mList.dataHandle )	{//take ownership of it if we are not owning it yet		mOwnList = true;		return noErr;//we own it, there is need to reassign	}	DisposeOfList();//destroy our previous data	mList = *inList;	mOwnList = true;	return noErr;}//releses ownership of the list//but does keep its dataAEDescListAEAliasList::DisownList(){	mOwnList = false;	return mList;}//disposes of the list only when we own it//or forgets its data if we do not own itvoidAEAliasList::DisposeOfList(){	if( mOwnList )	{		if( mList.dataHandle != NULL )		{			::AEDisposeDesc( &mList );		}	}	mList.descriptorType = typeNull;	mList.dataHandle = NULL;	//mOwnList = false;//it does not matter if we own an empty list or not}