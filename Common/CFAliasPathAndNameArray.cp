//**************************************************************************************// Filename:	CFAliasPathAndNameArray.cp//				Part of Contextual Menu Workshop by Abracode Inc.//				http://free.abracode.com/cmworkshop/// Copyright © 2002-2003 Abracode, Inc.  All rights reserved.//// Description:	CFArray-based list of aliases//				Design goals://				- not to throw//				- unique aliases (not to allow aliases pointing to the same object)//				- load and save aliases to preferences file via CFPreferences//				- access items (Add & Fetch) via FSRef//				- saves paths for easy display of unresolvable aliases//					path is only for display purposes, never used to getting the actual file reference//				- the object does own the array and deletes it////**************************************************************************************// Revision History:// Monday, August 19, 2002 - Original//**************************************************************************************#include "CFAliasPathAndNameArray.h"#include "CFObjDel.h"#include "AMacHandle.h"#include "CMUtils.h"#include "CFAliasArray.h"#include "CFAliasAndNameArray.h"#include "ACFNumber.h"//this code can load version 1, 2 or 3 types of arrays//version 1 is CFAliasArray//version 2 is CFAliasAndNameArray//version 3 is CFAliasPathAndNameArrayCFAliasPathAndNameArray::CFAliasPathAndNameArray(CFStringRef inKey, CFStringRef inPrefsIdentifier, CFIndex theVer /* = kTheLatestPrefsVersion */){	mArray = NULL;	if(theVer == 1)	{		LoadArrayFromPrefsVersion1(inKey, inPrefsIdentifier);	}	else if(theVer == 2)	{		LoadArrayFromPrefsVersion2(inKey, inPrefsIdentifier);	}	else if(theVer == kTheLatestPrefsVersion)	{		LoadArrayFromPrefs(inKey, inPrefsIdentifier);	}}CFAliasPathAndNameArray::CFAliasPathAndNameArray(const CFAliasPathAndNameArray& inArray){	mArray = ::CFArrayCreateMutableCopy ( kCFAllocatorDefault, 0, inArray.mArray );}CFAliasPathAndNameArray&CFAliasPathAndNameArray::operator=(const CFAliasPathAndNameArray& inArray){	if ( this != &inArray )	{		::CFRelease(mArray);		mArray = ::CFArrayCreateMutableCopy ( kCFAllocatorDefault, 0, inArray.mArray );	}	return *this;}//if inName is NULL, the name is obtained from filevoidCFAliasPathAndNameArray::AddPair(const FSRef *inRef, CFStringRef inName){	if(mArray == NULL)	 	return;//check if item exists in our list - do not add duplicates	OSStatus err = noErr;	CFIndex theCount = ::CFArrayGetCount(mArray);	for(CFIndex i = 0; i < theCount; i++)	{		CFTypeRef theItem = ::CFArrayGetValueAtIndex(mArray, i);  		  		if( (theItem != NULL) && (::CFGetTypeID(theItem) == ::CFDictionaryGetTypeID()) )  		{  			CFDictionaryRef theDict = (CFDictionaryRef)theItem;			CFTypeRef theResult = ::CFDictionaryGetValue( theDict, CFSTR("ALIAS_DATA") );  			if( (theResult != NULL) && (::CFDataGetTypeID() == ::CFGetTypeID(theResult)) )  			{  				CFDataRef dataRef = (CFDataRef)theResult;  				CFIndex theLen = ::CFDataGetLength(dataRef);  				AMacHandle<AliasRecord> newAliasH(theLen);  				if(newAliasH != NULL)  				{  					const UInt8 * dataPtr = ::CFDataGetBytePtr(dataRef);  					newAliasH.Lock();  					::BlockMoveData(dataPtr, *newAliasH, theLen);  					newAliasH.Unlock();  			  					FSRef newRef;  					Boolean wasChanged = false;  					err = ::FSResolveAliasWithMountFlags( NULL, newAliasH.Get(), &newRef, &wasChanged, kResolveAliasFileNoUI);  					if(err == noErr)  					{  						err = ::FSCompareFSRefs( inRef, &newRef );  						if(err == noErr)  						{//objects equal, do not add it to our list  							return;  						}  					}  				}  			}  		}	}	CFURLRef urlRef = ::CFURLCreateFromFSRef( kCFAllocatorDefault, inRef );	if(urlRef == NULL)		return;	CFObjDel urlDel(urlRef);//	CFStringRef pathStrRef = ::CFURLGetString( urlRef );//this is not a new created string, do not release it	CFStringRef pathStrRef = ::CFURLCopyFileSystemPath(urlRef, kCFURLPOSIXPathStyle);	CFObjDel pathStrDel(pathStrRef);	if(pathStrRef == NULL)		pathStrRef = CFSTR("/Unknown/Path/");		CFObjDel newStrDel;	if(inName == NULL)	{		inName = CMUtils::CreateCFStringNameFromFSRef(inRef);		newStrDel.Adopt(inName);	}	if(inName == NULL)		inName = CFSTR("Unknown Name");//add item	AliasHandle aliasH = NULL;	err = ::FSNewAlias( NULL, inRef, &aliasH);	if(aliasH == NULL)		return;	AHandle addAliasH((Handle)aliasH);//take ownership	if( err == noErr )	{		CFMutableDictionaryRef theDict = ::CFDictionaryCreateMutable(														kCFAllocatorDefault,														0,														&kCFTypeDictionaryKeyCallBacks,														&kCFTypeDictionaryValueCallBacks);		if(theDict == NULL)			return;  		CFObjDel newDictDel(theDict);  				addAliasH.Lock();		CFDataRef theDataRef = ::CFDataCreate( kCFAllocatorDefault, (const UInt8 *)*addAliasH, addAliasH.GetSize() );		if(theDataRef != NULL)		{			CFObjDel newDataDel(theDataRef);			::CFDictionaryAddValue( theDict, CFSTR("NAME"), inName);//the string is retained			::CFDictionaryAddValue( theDict, CFSTR("ALIAS_DATA"), theDataRef);//the data is retained			::CFDictionaryAddValue( theDict, CFSTR("PATH"), pathStrRef);//the string is retained			::CFArrayAppendValue( mArray, (const void *)theDict );//the dict is retained		}	}}voidCFAliasPathAndNameArray::AddItem(CFDictionaryRef inItem){	if((mArray == NULL) || (inItem == NULL))	 	return;	if(::CFGetTypeID(inItem) != ::CFDictionaryGetTypeID())		return;	CFDataRef aliasData = NULL;	CFTypeRef theResult = ::CFDictionaryGetValue( inItem, CFSTR("ALIAS_DATA") );	if( (theResult != NULL) && (::CFDataGetTypeID() == ::CFGetTypeID(theResult)) )	{  		aliasData  = (CFDataRef)theResult;	}		if(aliasData == NULL)		return;//alias data must exist - other stuff is optional			CFStringRef thePath = NULL;	theResult = ::CFDictionaryGetValue( inItem, CFSTR("PATH") );	if( (theResult != NULL) && (::CFStringGetTypeID() == ::CFGetTypeID(theResult)) )	{  		thePath  = (CFStringRef)theResult;	}		CFStringRef theName = NULL;	theResult = ::CFDictionaryGetValue( inItem, CFSTR("NAME") );	if( (theResult != NULL) && (::CFStringGetTypeID() == ::CFGetTypeID(theResult)) )	{  		theName  = (CFStringRef)theResult;	}		AddItemAliasPathAndName(aliasData, thePath, theName);}voidCFAliasPathAndNameArray::AddItemAliasPathAndName(CFDataRef inAliasData, CFStringRef inPath, CFStringRef inName){	if( (mArray == NULL) || (inAliasData == NULL))	 	return;	OSErr err = noErr;	CFObjDel nameStrDel;	CFObjDel pathStrDel;	if( (inPath == NULL) || (inName == NULL))	{//we try to resolve the alias in order to provide a path and name  		CFIndex theLen = ::CFDataGetLength(inAliasData);  		AMacHandle<AliasRecord> newAliasH(theLen);  		if(newAliasH == NULL)  			return;   		const UInt8 * dataPtr = ::CFDataGetBytePtr(inAliasData);  		newAliasH.Lock();  		::BlockMoveData(dataPtr, *newAliasH, theLen);  		newAliasH.Unlock();  			  		FSRef newRef;  		Boolean wasChanged = false;  		err = ::FSResolveAliasWithMountFlags( NULL, newAliasH.Get(), &newRef, &wasChanged, kResolveAliasFileNoUI);  		if(err == noErr)  		{//success resolving the alias  			if(inPath == NULL)  			{	  			CFURLRef urlRef = ::CFURLCreateFromFSRef( kCFAllocatorDefault, &newRef );				if(urlRef != NULL)				{					CFObjDel urlDel(urlRef);					//inPath = ::CFURLCopyPath(urlRef);					inPath = ::CFURLCopyFileSystemPath(urlRef, kCFURLPOSIXPathStyle);					pathStrDel.Adopt(inPath);				}			}						if(inName == NULL)			{				inName = CMUtils::CreateCFStringNameFromFSRef(&newRef);				nameStrDel.Adopt(inName);			}  		}  		if(inPath == NULL)  		{  			inPath = CFSTR("/Unresolved/Alias/Path/");  		}  				  		if(inName == NULL)  		{  			inName = CFSTR("Unresolved Alias Name");  		}    	}	if( err == noErr )	{		CFMutableDictionaryRef theDict = ::CFDictionaryCreateMutable(														kCFAllocatorDefault,														0,														&kCFTypeDictionaryKeyCallBacks,														&kCFTypeDictionaryValueCallBacks);		if(theDict == NULL)			return;  		CFObjDel newDictDel(theDict);		::CFDictionaryAddValue( theDict, CFSTR("NAME"), inName);//the string is retained		::CFDictionaryAddValue( theDict, CFSTR("ALIAS_DATA"), inAliasData);//the data is retained		::CFDictionaryAddValue( theDict, CFSTR("PATH"), inPath);//the string is retained		::CFArrayAppendValue( mArray, (const void *)theDict );//the dict is retained	}}//allow duplicates here because it is for the editor, user may want it for some reasonvoidCFAliasPathAndNameArray::InsertPairAt(const FSRef *inRef, CFStringRef inName, CFIndex inIndex){	if(mArray == NULL)	 	return;	CFObjDel newStrDel;	if(inName == NULL)	{		inName = CMUtils::CreateCFStringNameFromFSRef(inRef);		newStrDel.Adopt(inName);	}	if(inName == NULL)		inName = CFSTR("Unknown Name");	CFURLRef urlRef = ::CFURLCreateFromFSRef( kCFAllocatorDefault, inRef );	if(urlRef == NULL)		return;	CFObjDel urlDel(urlRef);//	CFStringRef pathStrRef = ::CFURLGetString( urlRef );//this is not a new created string, do not release it	CFStringRef pathStrRef = ::CFURLCopyFileSystemPath(urlRef, kCFURLPOSIXPathStyle);//add item	AliasHandle aliasH = NULL;	OSStatus err = ::FSNewAlias( NULL, inRef, &aliasH);	if((err != noErr) || (aliasH == NULL))		return;	AHandle addAliasH((Handle)aliasH);//take ownership	if( err == noErr )	{		CFMutableDictionaryRef theDict = ::CFDictionaryCreateMutable(														kCFAllocatorDefault,														0,														&kCFTypeDictionaryKeyCallBacks,														&kCFTypeDictionaryValueCallBacks);		if(theDict == NULL)			return;  		CFObjDel newDictDel(theDict);  				addAliasH.Lock();		CFDataRef theDataRef = ::CFDataCreate( kCFAllocatorDefault, (const UInt8 *)*addAliasH, addAliasH.GetSize() );		if(theDataRef != NULL)		{			CFObjDel newDataDel(theDataRef);			::CFDictionaryAddValue( theDict, CFSTR("NAME"), inName);//the string is retained			::CFDictionaryAddValue( theDict, CFSTR("ALIAS_DATA"), theDataRef);//the data is retained			::CFDictionaryAddValue( theDict, CFSTR("PATH"), pathStrRef);//the string is retained                        			::CFArrayInsertValueAtIndex(mArray, inIndex, (const void *)theDict);//the dict is retained		}	}}//index is zero-based//returns true if valid outRef set, false otherwiseBooleanCFAliasPathAndNameArray::FetchFSRefAt(CFIndex inIndex, FSRef &outRef) const{	if(mArray == NULL)	 	return false;	CFIndex theCount = ::CFArrayGetCount(mArray);	if( (inIndex >= 0) && (inIndex < theCount) )	{		CFTypeRef theItem = ::CFArrayGetValueAtIndex( mArray, inIndex);		if( (theItem != NULL) && (::CFGetTypeID(theItem) == ::CFDictionaryGetTypeID()) )		{			CFDictionaryRef theDict = (CFDictionaryRef)theItem;			CFTypeRef theResult = ::CFDictionaryGetValue( theDict, CFSTR("ALIAS_DATA") );			if( (theResult != NULL) && (::CFDataGetTypeID() == ::CFGetTypeID(theResult)) )			{  				CFDataRef dataRef = (CFDataRef)theResult;  				CFIndex theLen = ::CFDataGetLength(dataRef);  				AMacHandle<AliasRecord> newAliasH(theLen);  				if(newAliasH != NULL)  				{  					const UInt8 * dataPtr = ::CFDataGetBytePtr(dataRef);  					if(dataPtr != NULL)  					{  						newAliasH.Lock();  						::BlockMoveData(dataPtr, *newAliasH, theLen);  						newAliasH.Unlock();  						Boolean wasChanged = false;  						OSErr err = ::FSResolveAliasWithMountFlags( NULL, newAliasH.Get(), &outRef, &wasChanged, kResolveAliasFileNoUI);						return (err == noErr);					}				}			}		}	}	return false;}CFDataRefCFAliasPathAndNameArray::FetchAliasDataAt(CFIndex inIndex){	if(mArray == NULL)	 	return NULL;	CFIndex theCount = ::CFArrayGetCount(mArray);	if( (inIndex >= 0) && (inIndex < theCount) )	{		CFTypeRef theItem = ::CFArrayGetValueAtIndex( mArray, inIndex);		if( (theItem != NULL) && (::CFGetTypeID(theItem) == ::CFDictionaryGetTypeID()) )		{			CFDictionaryRef theDict = (CFDictionaryRef)theItem;			CFTypeRef theResult = ::CFDictionaryGetValue( theDict, CFSTR("ALIAS_DATA") );			if( (theResult != NULL) && (::CFDataGetTypeID() == ::CFGetTypeID(theResult)) )			{  				return (CFDataRef)theResult;			}		}	}	return NULL;}voidCFAliasPathAndNameArray::SetAliasDataAt(CFDataRef inData, CFIndex inIndex){	if(mArray == NULL)		return;			if(inData == NULL)	{		RemoveItemAt(inIndex);		return;	}		CFMutableDictionaryRef newDict = ReplaceDictionaryWithMutableCopyAt(inIndex);	if(newDict != NULL)		{		::CFDictionarySetValue(newDict, CFSTR("ALIAS_DATA"), inData);	}}BooleanCFAliasPathAndNameArray::FetchFSRefWithMountingAt(CFIndex inIndex, FSRef &outRef) const{	if(mArray == NULL)	 	return false;	CFIndex theCount = ::CFArrayGetCount(mArray);	if( (inIndex >= 0) && (inIndex < theCount) )	{		CFTypeRef theItem = ::CFArrayGetValueAtIndex( mArray, inIndex);		if( (theItem != NULL) && (::CFGetTypeID(theItem) == ::CFDictionaryGetTypeID()) )		{			CFDictionaryRef theDict = (CFDictionaryRef)theItem;			CFTypeRef theResult = ::CFDictionaryGetValue( theDict, CFSTR("ALIAS_DATA") );			if( (theResult != NULL) && (::CFDataGetTypeID() == ::CFGetTypeID(theResult)) )			{  				CFDataRef dataRef = (CFDataRef)theResult;  				CFIndex theLen = ::CFDataGetLength(dataRef);  				AMacHandle<AliasRecord> newAliasH(theLen);  				if(newAliasH != NULL)  				{  					const UInt8 * dataPtr = ::CFDataGetBytePtr(dataRef);  					if(dataPtr != NULL)  					{  						newAliasH.Lock();  						::BlockMoveData(dataPtr, *newAliasH, theLen);  						newAliasH.Unlock();  						Boolean wasChanged = false;  						OSErr err = ::FSResolveAlias( NULL, newAliasH.Get(), &outRef, &wasChanged);						return (err == noErr);					}				}			}		}	}	return false;}//do not release the result string - retain it if you plan to keep itCFStringRefCFAliasPathAndNameArray::FetchNameAt(CFIndex inIndex) const{	if(mArray == NULL)	 	return NULL;	CFIndex theCount = ::CFArrayGetCount(mArray);	if( (inIndex >= 0) && (inIndex < theCount) )	{		CFTypeRef theItem = ::CFArrayGetValueAtIndex( mArray, inIndex);				if( (theItem != NULL) && (::CFGetTypeID(theItem) == ::CFDictionaryGetTypeID()) )		{			CFDictionaryRef theDict = (CFDictionaryRef)theItem;			CFTypeRef theResult = ::CFDictionaryGetValue( theDict, CFSTR("NAME") );			if((theResult != NULL) && (::CFStringGetTypeID() == ::CFGetTypeID(theResult)) )			{				return (CFStringRef)theResult;			}		}		}	return NULL;}voidCFAliasPathAndNameArray::SetNameAt(CFStringRef inName, CFIndex inIndex){	if(mArray == NULL)		return;	CFMutableDictionaryRef newDict = ReplaceDictionaryWithMutableCopyAt(inIndex);	if(newDict != NULL)		{		if(inName != NULL)			::CFDictionarySetValue(newDict, CFSTR("NAME"), inName);		else			::CFDictionaryRemoveValue(newDict, CFSTR("NAME"));	}}//do not release the result string - retain it if you plan to keep itCFStringRefCFAliasPathAndNameArray::FetchPathAt(CFIndex inIndex) const{	if(mArray == NULL)	 	return NULL;	CFIndex theCount = ::CFArrayGetCount(mArray);	if( (inIndex >= 0) && (inIndex < theCount) )	{		CFTypeRef theItem = ::CFArrayGetValueAtIndex( mArray, inIndex);				if( (theItem != NULL) && (::CFGetTypeID(theItem) == ::CFDictionaryGetTypeID()) )		{			CFDictionaryRef theDict = (CFDictionaryRef)theItem;			CFTypeRef theResult = ::CFDictionaryGetValue( theDict, CFSTR("PATH") );			if((theResult != NULL) && (::CFStringGetTypeID() == ::CFGetTypeID(theResult)) )			{				return (CFStringRef)theResult;			}		}	}	return NULL;}voidCFAliasPathAndNameArray::SetPathAt(CFStringRef inPath, CFIndex inIndex){	if(mArray == NULL)		return;	CFMutableDictionaryRef newDict = ReplaceDictionaryWithMutableCopyAt(inIndex);	if(newDict != NULL)		{		if(inPath != NULL)			::CFDictionarySetValue(newDict, CFSTR("PATH"), inPath);		else			::CFDictionaryRemoveValue(newDict, CFSTR("PATH"));	}}voidCFAliasPathAndNameArray::SetFSRefAt(const FSRef &inRef, CFIndex inIndex){	if(mArray == NULL)	 	return;	CFMutableDictionaryRef newDict = ReplaceDictionaryWithMutableCopyAt(inIndex);	if(newDict != NULL)		{		AliasHandle aliasH = NULL;		OSErr err = ::FSNewAlias( NULL, &inRef, &aliasH);		if(aliasH == NULL)			return;		AHandle addAliasH((Handle)aliasH);//take ownership		if( err == noErr )		{			addAliasH.Lock();			CFDataRef theDataRef = ::CFDataCreate( kCFAllocatorDefault, (const UInt8 *)*addAliasH, addAliasH.GetSize() );			if(theDataRef != NULL)			{				CFObjDel newDataDel(theDataRef);				::CFDictionarySetValue( newDict, CFSTR("ALIAS_DATA"), theDataRef );//the data is retained			}		}	}}voidCFAliasPathAndNameArray::LoadArrayFromPrefsVersion1(CFStringRef inKey, CFStringRef inPrefsIdentifier){	if(mArray != NULL)	{		::CFRelease(mArray);		mArray = NULL;	}	mArray = ::CFArrayCreateMutable( kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks );	if( (inKey == NULL) || (inPrefsIdentifier == NULL) )	{				return;	}	//create old style array, get item one by one and add to our new-style array	CFAliasArray oldArray(inKey, inPrefsIdentifier);	CFIndex oldCount = oldArray.GetCount();	for(CFIndex i = 0; i < oldCount; i++)	{		CFDataRef aliasData = oldArray.FetchAliasDataAt(i);		if( aliasData != NULL )		{			AddItemAliasPathAndName(aliasData, NULL, NULL);		}	}}voidCFAliasPathAndNameArray::LoadArrayFromPrefsVersion2(CFStringRef inKey, CFStringRef inPrefsIdentifier){	if(mArray != NULL)	{		::CFRelease(mArray);		mArray = NULL;	}	mArray = ::CFArrayCreateMutable( kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks );	if( (inKey == NULL) || (inPrefsIdentifier == NULL) )	{				return;	}	//create old style array, get item one by one and add to our new-style array	CFAliasAndNameArray oldArray(inKey, inPrefsIdentifier, 2);	CFIndex oldCount = oldArray.GetCount();	for(CFIndex i = 0; i < oldCount; i++)	{		CFDictionaryRef oldDict = oldArray.FetchItemAt(i);		if(oldDict != NULL)		{			AddItem(oldDict);		}	}}