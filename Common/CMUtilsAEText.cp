//**************************************************************************************// Filename:	CMUtilsAEText.cp//				Part of Contextual Menu Workshop by Abracode Inc.//				http://free.abracode.com/cmworkshop///// Copyright © 2002-2003 Abracode, Inc.  All rights reserved.//// Description:	static utilities for Contextual Menu Plugins//////**************************************************************************************#include "CMUtils.h"#include "DebugSettings.h"#include "StAEDesc.h"#include "AStdArrayNew.h"BooleanCMUtils::AEDescHasTextData(const AEDesc &inDesc){#if _DEBUG_	Str31 debugStr;	DEBUG_STR( "\pAEDescHasTextData: data type is:" );	UInt8 *descPtr = (UInt8 *)&inDesc.descriptorType;	debugStr[0] = 4;	debugStr[1] = descPtr[0];	debugStr[2] = descPtr[1];	debugStr[3] = descPtr[2];	debugStr[4] = descPtr[3];		DEBUG_STR( debugStr );#endif	if( (inDesc.descriptorType == typeChar) || (inDesc.descriptorType == typeUnicodeText) )	{//try without coercing first		return (::AEGetDescDataSize( &inDesc ) > 0);	}	else if( (inDesc.descriptorType != typeNull) && (inDesc.dataHandle != NULL) )	{		StAEDesc textDesc;				if( ::AECoerceDesc(&inDesc, typeUnicodeText, textDesc) == noErr)		{			if( textDesc.GetDescriptorType() == typeUnicodeText ) 				if( textDesc.GetDataStorage() != NULL )					return (::AEGetDescDataSize(textDesc) > 0);		}		else if( ::AECoerceDesc(&inDesc, typeChar, textDesc) == noErr )		{			if( textDesc.GetDescriptorType() == typeChar ) 				if( textDesc.GetDataStorage() != NULL )					return (::AEGetDescDataSize(textDesc) > 0);		}	}		return false;}//returns null if descriptior does not contain textCFStringRefCMUtils::CreateCFStringFromAEDesc(const AEDesc &inDesc){	TRACE_STR( "\pCMUtils::CreateCFStringFromAEDesc" );#if _DEBUG_	Str31 debugStr;	DEBUG_STR( "\pAEDescHasTextData: data type is:" );	UInt8 *descPtr = (UInt8 *)&inDesc.descriptorType;	debugStr[0] = 4;	debugStr[1] = descPtr[0];	debugStr[2] = descPtr[1];	debugStr[3] = descPtr[2];	debugStr[4] = descPtr[3];		DEBUG_STR( debugStr );		if(inDesc.dataHandle != NULL)	{		DEBUG_STR( "\pAEDescHasTextData: dataHandle is not NULL" );	}	else	{		DEBUG_STR( "\pAEDescHasTextData: dataHandle is NULL" );	}#endif	CFStringRef outString = NULL;	if( (inDesc.descriptorType == typeUnicodeText) && (inDesc.dataHandle != NULL) )	{		Size byteCount = ::AEGetDescDataSize( &inDesc );		UniChar *newBuffer = (UniChar *)::NewPtrClear(byteCount);		if(newBuffer != NULL)		{			if( ::AEGetDescData( &inDesc, newBuffer, byteCount ) == noErr)			{				outString = ::CFStringCreateWithCharacters(kCFAllocatorDefault, newBuffer, byteCount/sizeof(UniChar) );			}				::DisposePtr( (Ptr)newBuffer );		}	}	else if( (inDesc.descriptorType == typeChar) && (inDesc.dataHandle != NULL) )	{		Size byteCount = ::AEGetDescDataSize( &inDesc );		char *newBuffer = ::NewPtrClear(byteCount);		if(newBuffer != NULL)		{			if( ::AEGetDescData( &inDesc, newBuffer, byteCount ) == noErr)			{				outString = ::CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8*)newBuffer, byteCount, CFStringGetSystemEncoding(), true);			}				::DisposePtr( (Ptr)newBuffer );		}	}	else if( (inDesc.descriptorType != typeNull) && (inDesc.dataHandle != NULL) ) 	{		StAEDesc textDesc;			if( ::AECoerceDesc(&inDesc, typeUnicodeText, textDesc) == noErr)		{			if(textDesc.GetDescriptorType() == typeUnicodeText) 				if(textDesc.GetDataStorage() != NULL)				{					Size byteCount = ::AEGetDescDataSize( textDesc );					UniChar *newBuffer = (UniChar *)::NewPtrClear(byteCount);					if(newBuffer != NULL)					{						if( ::AEGetDescData( textDesc, newBuffer, byteCount ) == noErr)						{							outString = ::CFStringCreateWithCharacters(kCFAllocatorDefault, newBuffer, byteCount/sizeof(UniChar) );						}							::DisposePtr( (Ptr)newBuffer );					}				}		}		else if( ::AECoerceDesc(&inDesc, typeChar, textDesc) == noErr)		{			if(textDesc.GetDescriptorType() == typeChar) 				if(textDesc.GetDataStorage() != NULL)				{					Size byteCount = ::AEGetDescDataSize( textDesc );					char *newBuffer = ::NewPtrClear(byteCount);					if(newBuffer != NULL)					{						if( ::AEGetDescData( textDesc, newBuffer, byteCount ) == noErr)						{							outString = ::CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8*)newBuffer, byteCount, CFStringGetSystemEncoding(), true);						}							::DisposePtr( (Ptr)newBuffer );					}				}		}	}	if(outString == NULL)	{		DEBUG_STR( "\pCMUtils::CreateCFStringFromAEDesc: NULL string returned" );	}	return outString;}OSStatusCMUtils::CreateUniTextDescFromCFString(CFStringRef inStringRef, AEDesc &outDesc){	if(inStringRef == NULL) return paramErr;	CFIndex uniCount = ::CFStringGetLength(inStringRef);	const UniChar *uniString = ::CFStringGetCharactersPtr(inStringRef);	if( uniString != NULL )	{		return ::AECreateDesc(typeUnicodeText, uniString, uniCount*sizeof(UniChar), &outDesc);	}		AStdArrayNew<UniChar> newString(uniCount);	CFRange theRange;	theRange.location = 0;	theRange.length = uniCount;	::CFStringGetCharacters( inStringRef, theRange, newString.Get());	return ::AECreateDesc(typeUnicodeText, newString.Get(), uniCount*sizeof(UniChar), &outDesc);}