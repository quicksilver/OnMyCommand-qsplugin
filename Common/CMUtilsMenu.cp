//**************************************************************************************// Filename:	CMUtils.cp//				Part of Contextual Menu Workshop by Abracode Inc.//				http://free.abracode.com/cmworkshop///// Copyright © 2002-2003 Abracode, Inc.  All rights reserved.//// Description:	static utilities for Contextual Menu Plugins//	// TODO:		split into several separate smaller files because the linker in ProjectBuilder//				is not able to optimize the ouput binary and links all functions, even those unused (sic!) //////**************************************************************************************#include "CMUtils.h"#include "AStdArrayNew.h"#include "DebugSettings.h"#include "StAEDesc.h"#if defined(__MACH__)	#import <Carbon/Carbon.h>#else	#include <Menus.h>#endif#if UNIVERSAL_INTERFACES_VERSION < 0x0342//these enums used to be present in ContextualMenuPlugins.h, now they are defined in Menus.henum{	keyContextualMenuCommandID				=	'cmcd',	keyContextualMenuSubmenu				=	'cmsb'};#endif//res file must be open for this function//this function reads command string from STR# resourceOSStatusCMUtils::AddResCommand( AEDescList* ioCommands,						short stringsID, short strIndex,						SInt32 inCommandID,						MenuItemAttributes attributes /*= 0*/,						UInt32 modifiers /*= kMenuNoModifiers*/){	Str255 commandString;	::GetIndString(commandString, stringsID, strIndex);	if( commandString[0] > 0)		return CMUtils::AddCommandToAEDescList(commandString, inCommandID, ioCommands, attributes, modifiers);		return resNotFound;}// ---------------------------------------------------------------------------// AddCommandToAEDescList// ---------------------------------------------------------------------------OSStatus CMUtils::AddCommandToAEDescList(	ConstStr255Param inCommandString,									SInt32 inCommandID,									AEDescList* ioCommandList,									MenuItemAttributes attributes /*= 0*/,									UInt32 modifiers /*= kMenuNoModifiers*/){	if( (inCommandString == NULL) || (ioCommandList == NULL) )		return paramErr;//	TRACE_STR( "\pCMUtils. AddCommandToAEDescList with Str255" );	OSStatus err = noErr;		StAEDesc theCommandRecord;//AERecord		// create an apple event record for our command	err = ::AECreateList(NULL, 0, true, theCommandRecord);	if (err != noErr) return err;			// stick the command text into the AERecord	err = ::AEPutKeyPtr( theCommandRecord, keyContextualMenuName /*keyAEName*/, typeChar, &inCommandString[1], inCommandString[0]);	if (err != noErr) return err;				// stick the command ID into the AERecord	err = ::AEPutKeyPtr( theCommandRecord, keyContextualMenuCommandID, typeLongInteger, &inCommandID, sizeof (inCommandID));	if (err != noErr) return err;	//stick menu attributes into AERecord	if(attributes != 0)	{		err = ::AEPutKeyPtr( theCommandRecord, keyContextualMenuAttributes, typeLongInteger, &attributes, sizeof (attributes));		if (err != noErr) return err;	}	//stick menu modifiers into AERecord	if(modifiers != kMenuNoModifiers)	{		err = ::AEPutKeyPtr( theCommandRecord, keyContextualMenuModifiers, typeLongInteger, &modifiers, sizeof (UInt32));		if (err != noErr) return err;	}	// stick this record into the list of commands that we are passing back to CMM	err = ::AEPutDesc(	ioCommandList, // the list we're putting our command into						0, // stick this command onto the end of our list						theCommandRecord); // the command I'm putting into the list    return err;}OSStatus CMUtils::AddCommandToAEDescList( const UniChar *inCommandString,										UniCharCount inCount,										SInt32 inCommandID,										AEDescList* ioCommandList,										MenuItemAttributes attributes /*= 0*/,										UInt32 modifiers /*= kMenuNoModifiers*/){	if( (inCommandString == NULL) || (ioCommandList == NULL) )		return paramErr;//	TRACE_STR( "\pCMUtils. AddCommandToAEDescList with Unicode characters" );	OSStatus err = noErr;		StAEDesc theCommandRecord;//AERecord		// create an apple event record for our command	err = ::AECreateList(NULL, 0, true, theCommandRecord);	if (err != noErr) return err;			// stick the command text into the AERecord	err = ::AEPutKeyPtr( theCommandRecord, keyContextualMenuName /*keyAEName*/, typeUnicodeText, inCommandString, inCount*sizeof(UniChar));	if (err != noErr) return err;				// stick the command ID into the AERecord	err = ::AEPutKeyPtr( theCommandRecord, keyContextualMenuCommandID, typeLongInteger, &inCommandID, sizeof (inCommandID));	if (err != noErr) return err;	//stick menu attributes into AERecord	if(attributes != 0)	{		err = ::AEPutKeyPtr( theCommandRecord, keyContextualMenuAttributes, typeLongInteger, &attributes, sizeof (attributes));		if (err != noErr) return err;	}	//stick menu modifiers into AERecord	if(modifiers != kMenuNoModifiers)	{		err = ::AEPutKeyPtr( theCommandRecord, keyContextualMenuModifiers, typeLongInteger, &modifiers, sizeof (UInt32));		if (err != noErr) return err;	}		// stick this record into the list of commands that we are passing back to CMM	err = ::AEPutDesc(	ioCommandList, // the list we're putting our command into						0, // stick this command onto the end of our list						theCommandRecord); // the command I'm putting into the list    return err;}OSStatus CMUtils::AddCommandToAEDescList(	CFStringRef inCommandString,									SInt32 inCommandID,									Boolean putCFString, //available starting with OS 10.2									AEDescList* ioCommandList,									MenuItemAttributes attributes /*= 0*/,									UInt32 modifiers /*= kMenuNoModifiers*/){	if(putCFString == false)		return AddCommandToAEDescList_Compatible( inCommandString, inCommandID, ioCommandList, attributes, modifiers );	if( (inCommandString == NULL) || (ioCommandList == NULL) )		return paramErr;//	TRACE_STR( "\pCMUtils. AddCommandToAEDescList with CFString" );	OSStatus err = noErr;		StAEDesc theCommandRecord;//AERecord		// create an apple event record for our command	err = ::AECreateList(NULL, 0, true, theCommandRecord);	if (err != noErr) return err;	/*	Apple documentation says:   * If you provide data as typeCFStringRef, the Contextual Menu Manager will   * automatically release the CFStringRef once the menu has been   * displayed. If you need the CFStringRef to have a longer timetime,   * your plugin should retain the CFStringRef before inserting it into   * the AERecord.*/	//_tk_ comment	//it is not said explicitly if Contextual Menu Manager retains the CFString.	//However, a little bit of experimenting (and crashing) shows that	//IT DOES NOT RETAIN the CFString, it takes onwership of the string without retaining it	//We do not "own" the string here so we must retain it	//to balance the release which will be done by Contextual Menu Manager	::CFRetain(inCommandString);	// stick the command text into the AERecord	err = ::AEPutKeyPtr( theCommandRecord, keyContextualMenuName, typeCFStringRef, &inCommandString, sizeof(CFStringRef));	if (err != noErr) return err;	// stick the command ID into the AERecord	err = ::AEPutKeyPtr( theCommandRecord, keyContextualMenuCommandID, typeLongInteger, &inCommandID, sizeof (inCommandID));	if (err != noErr) return err;	//stick menu attributes into AERecord	if(attributes != 0)	{		err = ::AEPutKeyPtr( theCommandRecord, keyContextualMenuAttributes, typeLongInteger, &attributes, sizeof(attributes));		if (err != noErr) return err;	}	//stick menu modifiers into AERecord	if(modifiers != kMenuNoModifiers)	{		err = ::AEPutKeyPtr( theCommandRecord, keyContextualMenuModifiers, typeLongInteger, &modifiers, sizeof (UInt32));		if (err != noErr) return err;	}		// stick this record into the list of commands that we are passing back to CMM	err = ::AEPutDesc(	ioCommandList, // the list we're putting our command into						0, // stick this command onto the end of our list						theCommandRecord); // the command I'm putting into the list    return err;}//This method is compatible with 10.1.x OSStatus CMUtils::AddCommandToAEDescList_Compatible(	CFStringRef inCommandString,									SInt32 inCommandID,									AEDescList* ioCommandList,									MenuItemAttributes attributes /*= 0*/,									UInt32 modifiers /*= kMenuNoModifiers*/ ){	if( inCommandString == NULL )		return paramErr;//	TRACE_STR( "\pCMUtils. AddCommandToAEDescList with CFString" );	CFIndex uniCount = ::CFStringGetLength(inCommandString);	const UniChar *uniString = ::CFStringGetCharactersPtr(inCommandString);	if( uniString != NULL )		return CMUtils::AddCommandToAEDescList(	uniString, uniCount, inCommandID, ioCommandList, attributes, modifiers );//CFStringGetCharactersPtr failed and we must copy the string	UniChar *newString = new UniChar[uniCount];	AStdArrayNew<UniChar> theDel(newString);	CFRange theRange;	theRange.location = 0;	theRange.length = uniCount;	::CFStringGetCharacters( inCommandString, theRange, newString);	OSStatus outErr = CMUtils::AddCommandToAEDescList(	newString, uniCount, inCommandID, ioCommandList, attributes, modifiers );//	delete [] newString;		return outErr;}//based on SampleCMPlugin.cOSStatusCMUtils::AddSubmenu( AEDescList* ioCommands, short stringsID, short superStrIndex, AEDescList &inSubList ){//	TRACE_STR( "\pCMUtils. AddSubmenu with name from resources" );	Str255 commandString;	commandString[0] = 0;	::GetIndString(commandString, stringsID, superStrIndex);	if( commandString[0] == 0)		return resNotFound;	StAEDesc	theSupercommand; //AERecord	// create an apple event record for our supercommand	OSStatus err = ::AECreateList( NULL, 0, true, theSupercommand );	if (err != noErr) return err;	// stick the command text into the AERecord	err = ::AEPutKeyPtr( theSupercommand, keyContextualMenuName /*keyAEName*/, typeChar, &commandString[1], commandString[0] );	if (err != noErr) return err;				// stick the subcommands into into the AERecord	err = ::AEPutKeyDesc( theSupercommand, keyContextualMenuSubmenu, &inSubList );	if (err != noErr) return err;	// stick the supercommand into the list of commands that we are passing back to the CMM	err = ::AEPutDesc(	ioCommands,			// the list we're putting our command into						0,					// stick this command onto the end of our list						theSupercommand );	// the command I'm putting into the list	return err;}OSStatusCMUtils::AddSubmenu( AEDescList* ioCommands, CFStringRef inName, AEDescList &inSubList ){	if( inName == NULL )		return paramErr;//	TRACE_STR( "\pCMUtils. AddSubmenu with CFString" );	CFIndex uniCount = ::CFStringGetLength(inName);	const UniChar *uniString = ::CFStringGetCharactersPtr(inName);	if( uniString != NULL )		return CMUtils::AddSubmenu(	ioCommands, uniString, uniCount, inSubList );//CFStringGetCharactersPtr failed and we must copy the string	UniChar *newString = new UniChar[uniCount];	CFRange theRange;	theRange.location = 0;	theRange.length = uniCount;	::CFStringGetCharacters( inName, theRange, newString);	OSStatus outErr = CMUtils::AddSubmenu( ioCommands, newString, uniCount, inSubList );	delete [] newString;		return outErr;}OSStatus CMUtils::AddSubmenu( AEDescList* ioCommands, 					const UniChar *inName,					UniCharCount inCount,					AEDescList &inSubList ){	if( (inName == NULL) || (ioCommands == NULL) )		return paramErr;//	TRACE_STR( "\pCMUtils. AddSubmenu with Unicode characters" );	StAEDesc	theSupercommand; //AERecord	// create an apple event record for our supercommand	OSStatus err = ::AECreateList( NULL, 0, true, theSupercommand );	if (err != noErr) return err;	// stick the command text into the AERecord	err = ::AEPutKeyPtr( theSupercommand, keyContextualMenuName /*keyAEName*/, typeUnicodeText, inName, inCount*sizeof(UniChar) );	if (err != noErr) return err;				// stick the subcommands into into the AERecord	err = ::AEPutKeyDesc( theSupercommand, keyContextualMenuSubmenu, &inSubList );	if (err != noErr) return err;	// stick the supercommand into the list of commands that we are passing back to the CMM	err = ::AEPutDesc(	ioCommands,			// the list we're putting our command into						0,					// stick this command onto the end of our list						theSupercommand );	// the command I'm putting into the list	return err;}